<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Asistente de Viaje v2.0.0</title>
    <meta name="description" content="Bit√°cora de viajes y gastos offline con optimizaciones avanzadas">
    <meta name="theme-color" content="#0f172a">
    
    <!-- Enlace al Manifiesto (Necesario para PWA) -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- 1. Estilos: Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React y ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
            overscroll-behavior-y: none;
            background-color: #f1f5f9;
        }
        input, textarea, select {
            user-select: text;
        }
        /* Ocultar scrollbar pero mantener funcionalidad */
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .animate-slide-in-top {
            animation: slideInTop 0.3s ease-out forwards;
        }
        @keyframes slideInTop {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilos para gr√°ficos simples */
        .progress-ring {
            transform: rotate(-90deg);
        }
        .progress-ring-circle {
            transition: stroke-dashoffset 0.5s ease;
            stroke-linecap: round;
        }
        .highlight-row {
            animation: highlight 1.5s ease-out;
        }
        @keyframes highlight {
            0% { background-color: rgba(34, 197, 94, 0.1); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, memo } = React;

        // ==========================================
        // 1. SISTEMA DE ICONOS INTEGRADO (MEMOIZADO)
        // ==========================================
        const ICONS = {
            Play: <polygon points="5 3 19 12 5 21 5 3" />,
            MapPin: <><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" /><circle cx="12" cy="10" r="3" /></>,
            DollarSign: <><line x1="12" x2="12" y1="2" y2="22" /><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" /></>,
            Clock: <><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></>,
            Car: <path d="M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" />,
            AlertTriangle: <><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><line x1="12" x2="12" y1="9" y2="13" /><line x1="12" x2="12.01" y1="17" y2="17" /></>,
            CheckCircle: <><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></>,
            Plus: <><line x1="12" x2="12" y1="5" y2="19" /><line x1="5" x2="19" y1="12" y2="12" /></>,
            Settings: <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />,
            Fuel: <><line x1="3" x2="15" y1="22" y2="22" /><line x1="4" x2="14" y1="9" y2="9" /><path d="M14 22V4a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v18" /><path d="M14 13h2a2 2 0 0 1 2 2v2a2 2 0 0 0 2 2h0a2 2 0 0 0 2-2V9.83a2 2 0 0 0-.59-1.42L18 5" /></>,
            Utensils: <><path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2" /><path d="M7 2v20" /><path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7" /></>,
            Bed: <><path d="M2 4v16" /><path d="M2 8h18a2 2 0 0 1 2 2v10" /><path d="M2 17h20" /><path d="M6 8v9" /></>,
            Briefcase: <><rect width="20" height="14" x="2" y="7" rx="2" ry="2" /><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" /></>,
            CreditCard: <><rect width="20" height="14" x="2" y="5" rx="2" /><line x1="2" x2="22" y1="10" y2="10" /></>,
            Wallet: <path d="M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4" />,
            Landmark: <><line x1="3" x2="21" y1="22" y2="22" /><line x1="6" x2="6" y1="18" y2="11" /><line x1="10" x2="10" y1="18" y2="11" /><line x1="14" x2="14" y1="18" y2="11" /><line x1="18" x2="18" y1="18" y2="11" /><polygon points="12 2 20 7 4 7" /></>,
            X: <><path d="M18 6 6 18" /><path d="m6 6 12 12" /></>,
            Save: <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></>,
            Zap: <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />,
            Truck: <><rect width="16" height="13" x="1" y="6" rx="2" /><polygon points="17 10 22 11 22 17 17 17 17 10" /></>,
            Edit2: <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" />,
            ChevronDown: <path d="m6 9 6 6 6-6" />,
            ShoppingBag: <><path d="M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4Z" /><path d="M3 6h18" /><path d="M16 10a4 4 0 0 1-8 0" /></>,
            History: <><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /><path d="M12 7v5l4 2" /></>,
            User: <><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></>,
            Users: <><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></>,
            StickyNote: <><path d="M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z" /><path d="M15 3v6h6" /></>,
            ArrowRight: <path d="M5 12h14M12 5l7 7-7 7" />,
            Trash2: <><path d="M3 6h18" /><path d="M19 6v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V6" /><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></>,
            Calendar: <><rect width="18" height="18" x="3" y="4" rx="2" ry="2" /><line x1="16" x2="16" y1="2" y2="6" /><line x1="8" x2="8" y1="2" y2="6" /><line x1="3" x2="21" y1="10" y2="10" /></>,
            Home: <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />,
            Search: <><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></>,
            Filter: <><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></>,
            Download: <><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></>,
            TrendingUp: <><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></>,
            PieChart: <><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></>,
            BarChart: <><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></>
        };

        // Componente Icon memoizado
        const Icon = memo(({ name, size = 24, className = "" }) => {
            if (!ICONS[name]) return null;
            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round" 
                    className={className}
                >
                    {ICONS[name]}
                </svg>
            );
        });

        // ==========================================
        // 2. CONSTANTES Y CONFIGURACIONES
        // ==========================================
        const LOCATIONS_CONFIG = {
            'Cliente': { icon: 'User', color: 'text-blue-600', bg: 'bg-blue-50', border: 'border-blue-200' },
            'Trabajo': { icon: 'Briefcase', color: 'text-slate-600', bg: 'bg-slate-50', border: 'border-slate-200' },
            'Casa': { icon: 'Home', color: 'text-indigo-600', bg: 'bg-indigo-50', border: 'border-indigo-200' },
            'Restaurante': { icon: 'Utensils', color: 'text-orange-600', bg: 'bg-orange-50', border: 'border-orange-200' },
            'Hotel': { icon: 'Bed', color: 'text-violet-600', bg: 'bg-violet-50', border: 'border-violet-200' },
            'Otra': { icon: 'MapPin', color: 'text-gray-600', bg: 'bg-gray-50', border: 'border-gray-200' }
        };
        const LOCATIONS_PRESETS = Object.keys(LOCATIONS_CONFIG);

        const EXPENSE_CATEGORIES = {
            FOOD: ['Desayuno', 'Almuerzo', 'Merienda', 'Cena', 'Refrigerio'],
            LODGING: ['Alojamiento'],
            TRIP: ['Peaje', 'Estacionamiento', 'Carga Combustible', 'Carga El√©ctrica'],
            OTHER: ['Otros']
        };

        const PAYMENT_METHODS = [
            { id: 'EFECTIVO', label: 'Efectivo', icon: 'Wallet' },
            { id: 'DEBITO', label: 'D√©bito', icon: 'CreditCard' },
            { id: 'CREDITO', label: 'Cr√©dito', icon: 'CreditCard' },
            { id: 'TRANSFERENCIA', label: 'Transferencia', icon: 'Landmark' },
        ];

        const CURRENCIES = ['UYU', 'U$D', 'Otro'];
        const EXPENSE_TYPES = ['Personal', 'Empresa'];

        const VEHICLE_TYPES = [
            { id: 'PERSONAL', label: 'Personal', short: 'Personal', icon: 'Car', type: 'fuel' },
            { id: 'COMPANY_FUEL', label: 'Empresa Combustible', short: 'Emp. Comb.', icon: 'Truck', type: 'fuel' },
            { id: 'COMPANY_ELECTRIC', label: 'Empresa El√©ctrico', short: 'Emp. Elec.', icon: 'Zap', type: 'electric' },
            { id: 'OTHER', label: 'Otros', short: 'Otros', icon: 'Car', type: 'fuel' },
        ];

        // TARIFAS OFICIALES URUGUAY 2025
        const OFFICIAL_RATES = {
            toll: '162.00',
            fuel: '78.02', // Super 95
            electricAC: '9.50',
            electricDC: '10.80'
        };

        // ==========================================
        // 3. SISTEMA DE VALIDACI√ìN
        // ==========================================
        const VALIDATORS = {
            amount: (value) => {
                const num = parseFloat(value);
                return !isNaN(num) && num >= 0 && num <= 1000000;
            },
            odometer: (value, min = 0, max = 999999) => {
                const num = parseInt(value);
                return !isNaN(num) && num >= min && num <= max;
            },
            text: (value, minLength = 1, maxLength = 100) => {
                return value && value.trim().length >= minLength && value.length <= maxLength;
            },
            date: (value) => {
                const date = new Date(value);
                return date instanceof Date && !isNaN(date);
            }
        };

        // ==========================================
        // 4. INDEXEDDB CON MIGRACIONES (MEJORADO)
        // ==========================================
        const DB_NAME = 'TripAssistantDB_v2';
        const DB_VERSION = 3; // Incrementado para migraciones

        // Esquema de migraciones
        const MIGRATIONS = {
            1: (db) => {
                // Versi√≥n 1: Store simple
                if (!db.objectStoreNames.contains('app_data')) {
                    db.createObjectStore('app_data');
                }
            },
            2: (db) => {
                // Versi√≥n 2: Stores separados
                if (!db.objectStoreNames.contains('trips')) {
                    const tripStore = db.createObjectStore('trips', { keyPath: 'id' });
                    tripStore.createIndex('date', 'date', { unique: false });
                    tripStore.createIndex('vehicle', 'vehicle', { unique: false });
                }
                if (!db.objectStoreNames.contains('expenses')) {
                    const expenseStore = db.createObjectStore('expenses', { keyPath: 'id' });
                    expenseStore.createIndex('date', 'date', { unique: false });
                    expenseStore.createIndex('category', 'category', { unique: false });
                }
                if (!db.objectStoreNames.contains('visits')) {
                    const visitStore = db.createObjectStore('visits', { keyPath: 'id' });
                    visitStore.createIndex('client', 'client', { unique: false });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            },
            3: (db) => {
                // Versi√≥n 3: √çndices adicionales y nuevos campos
                const transaction = db.transaction(['trips', 'expenses'], 'readwrite');
                
                // Agregar √≠ndice de distancia a trips
                const tripStore = transaction.objectStore('trips');
                if (!tripStore.indexNames.contains('distance')) {
                    tripStore.createIndex('distance', 'distance', { unique: false });
                }
                
                // Agregar √≠ndice de monto a expenses
                const expenseStore = transaction.objectStore('expenses');
                if (!expenseStore.indexNames.contains('amount')) {
                    expenseStore.createIndex('amount', 'amount', { unique: false });
                }
                
                // Agregar √≠ndice de tipo de gasto
                if (!expenseStore.indexNames.contains('type')) {
                    expenseStore.createIndex('type', 'type', { unique: false });
                }
            }
        };

        const dbHelper = {
            init: () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const oldVersion = event.oldVersion;
                        const newVersion = event.newVersion;
                        
                        console.log(`üîß Migrando DB de v${oldVersion} a v${newVersion}`);
                        
                        // Ejecutar migraciones incrementales
                        for (let version = oldVersion; version < newVersion; version++) {
                            const migration = MIGRATIONS[version + 1];
                            if (migration) {
                                try {
                                    migration(db);
                                    console.log(`‚úÖ Migraci√≥n v${version + 1} aplicada`);
                                } catch (error) {
                                    console.error(`‚ùå Error en migraci√≥n v${version + 1}:`, error);
                                }
                            }
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        console.log("‚úÖ DB inicializada correctamente");
                        
                        // Verificar integridad de datos
                        dbHelper.checkDataIntegrity(db).then(isValid => {
                            if (!isValid) {
                                console.warn("‚ö†Ô∏è Problemas de integridad detectados, intentando reparar...");
                                dbHelper.repairDatabase(db);
                            }
                            resolve(db);
                        });
                    };
                    
                    request.onerror = (event) => {
                        console.error("‚ùå Error cr√≠tico DB:", event.target.error);
                        reject(event.target.error);
                    };
                });
            },
            
            checkDataIntegrity: async (db) => {
                return new Promise((resolve) => {
                    const transaction = db.transaction(['trips', 'expenses', 'visits'], 'readonly');
                    let errorCount = 0;
                    
                    // Verificar trips
                    const tripStore = transaction.objectStore('trips');
                    const tripRequest = tripStore.getAll();
                    
                    tripRequest.onsuccess = () => {
                        const trips = tripRequest.result;
                        trips.forEach(trip => {
                            if (!trip.id || !trip.date || trip.distance < 0) {
                                errorCount++;
                            }
                        });
                    };
                    
                    // Verificar expenses
                    const expenseStore = transaction.objectStore('expenses');
                    const expenseRequest = expenseStore.getAll();
                    
                    expenseRequest.onsuccess = () => {
                        const expenses = expenseRequest.result;
                        expenses.forEach(expense => {
                            if (!expense.id || !expense.amount || expense.amount < 0) {
                                errorCount++;
                            }
                        });
                        
                        resolve(errorCount === 0);
                    };
                });
            },
            
            repairDatabase: async (db) => {
                return new Promise((resolve) => {
                    const transaction = db.transaction(['trips', 'expenses'], 'readwrite');
                    
                    // Reparar trips
                    const tripStore = transaction.objectStore('trips');
                    const tripRequest = tripStore.getAll();
                    
                    tripRequest.onsuccess = () => {
                        const trips = tripRequest.result;
                        trips.forEach(trip => {
                            if (!trip.id) {
                                trip.id = Date.now() + Math.random();
                                tripStore.put(trip);
                            }
                            if (trip.distance < 0) {
                                trip.distance = Math.abs(trip.distance);
                                tripStore.put(trip);
                            }
                        });
                    };
                    
                    // Reparar expenses
                    const expenseStore = transaction.objectStore('expenses');
                    const expenseRequest = expenseStore.getAll();
                    
                    expenseRequest.onsuccess = () => {
                        const expenses = expenseRequest.result;
                        expenses.forEach(expense => {
                            if (!expense.id) {
                                expense.id = Date.now() + Math.random();
                                expenseStore.put(expense);
                            }
                            if (expense.amount < 0) {
                                expense.amount = Math.abs(expense.amount);
                                expenseStore.put(expense);
                            }
                        });
                        
                        resolve();
                    };
                });
            },
            
            get: async (storeName, key) => {
                try {
                    const db = await dbHelper.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        const request = key ? store.get(key) : store.getAll();
                        
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn(`DB Get Error para ${storeName}:`, error);
                    return key ? null : [];
                }
            },
            
            set: async (storeName, data) => {
                try {
                    const db = await dbHelper.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction([storeName], 'readwrite');
                        const store = transaction.objectStore(storeName);
                        
                        if (Array.isArray(data)) {
                            // Guardar m√∫ltiples items
                            data.forEach(item => store.put(item));
                        } else {
                            // Guardar item individual
                            store.put(data);
                        }
                        
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => reject(transaction.error);
                    });
                } catch (error) {
                    console.error(`DB Set Error para ${storeName}:`, error);
                    throw error;
                }
            },
            
            delete: async (storeName, key) => {
                try {
                    const db = await dbHelper.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction([storeName], 'readwrite');
                        const store = transaction.objectStore(storeName);
                        const request = store.delete(key);
                        
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error(`DB Delete Error para ${storeName}:`, error);
                    throw error;
                }
            },
            
            query: async (storeName, indexName, range, direction = 'next') => {
                try {
                    const db = await dbHelper.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        const index = store.index(indexName);
                        const request = index.openCursor(range, direction);
                        const results = [];
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                results.push(cursor.value);
                                cursor.continue();
                            } else {
                                resolve(results);
                            }
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error(`DB Query Error para ${storeName}.${indexName}:`, error);
                    return [];
                }
            }
        };

        // ==========================================
        // 5. COMPONENTES REUTILIZABLES (MEMOIZADOS)
        // ==========================================

        // Componente de Notificaciones Toast (memoizado)
        const ToastNotification = memo(({ message, type = 'error', duration = 5000 }) => {
            const [visible, setVisible] = useState(true);
            
            useEffect(() => {
                const timer = setTimeout(() => setVisible(false), duration);
                return () => clearTimeout(timer);
            }, [duration]);
            
            if (!visible) return null;
            
            const bgColor = type === 'error' ? 'bg-rose-50 border-rose-200' : 
                          type === 'success' ? 'bg-emerald-50 border-emerald-200' : 
                          'bg-blue-50 border-blue-200';
            const textColor = type === 'error' ? 'text-rose-700' : 
                           type === 'success' ? 'text-emerald-700' : 
                           'text-blue-700';
            
            return (
                <div className={`fixed top-4 right-4 left-4 max-w-sm mx-auto z-[1000] border rounded-xl p-4 shadow-lg animate-slide-in-top ${bgColor}`}>
                    <div className="flex items-center">
                        <Icon 
                            name={type === 'error' ? 'AlertTriangle' : 'CheckCircle'} 
                            size={20} 
                            className={`mr-2 ${textColor}`}
                        />
                        <span className={`font-medium ${textColor}`}>{message}</span>
                    </div>
                </div>
            );
        });

        // Componente de Progress Ring para estad√≠sticas
        const ProgressRing = memo(({ progress, size = 60, strokeWidth = 6, color = '#10b981' }) => {
            const radius = (size - strokeWidth) / 2;
            const circumference = radius * 2 * Math.PI;
            const strokeDashoffset = circumference - (progress / 100) * circumference;
            
            return (
                <svg width={size} height={size} className="progress-ring">
                    <circle
                        stroke="#e2e8f0"
                        strokeWidth={strokeWidth}
                        fill="transparent"
                        r={radius}
                        cx={size / 2}
                        cy={size / 2}
                    />
                    <circle
                        stroke={color}
                        strokeWidth={strokeWidth}
                        fill="transparent"
                        r={radius}
                        cx={size / 2}
                        cy={size / 2}
                        strokeDasharray={`${circumference} ${circumference}`}
                        strokeDashoffset={strokeDashoffset}
                        className="progress-ring-circle"
                    />
                </svg>
            );
        });

        // Componente de Filtros (memoizado)
        const FilterPanel = memo(({ 
            filters, 
            onFilterChange, 
            availableVehicles, 
            availableCategories,
            availablePaymentMethods 
        }) => {
            const [showAdvanced, setShowAdvanced] = useState(false);
            
            return (
                <div className="bg-white rounded-xl p-4 shadow-sm border border-slate-100 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-slate-700 flex items-center">
                            <Icon name="Filter" size={18} className="mr-2 text-blue-500"/> Filtros
                        </h3>
                        <button 
                            onClick={() => setShowAdvanced(!showAdvanced)}
                            className="text-sm text-blue-600 font-medium hover:text-blue-800"
                        >
                            {showAdvanced ? 'Simple' : 'Avanzado'} ‚ñº
                        </button>
                    </div>
                    
                    <div className="space-y-3">
                        {/* B√∫squeda b√°sica */}
                        <div className="relative">
                            <Icon name="Search" size={18} className="absolute left-3 top-3 text-slate-400"/>
                            <input
                                type="text"
                                placeholder="Buscar..."
                                value={filters.search || ''}
                                onChange={(e) => onFilterChange('search', e.target.value)}
                                className="w-full pl-10 pr-3 py-2 bg-slate-50 border border-slate-200 rounded-lg text-slate-700 focus:outline-none focus:border-blue-500"
                            />
                        </div>
                        
                        {/* Filtros r√°pidos */}
                        <div className="flex gap-2 overflow-x-auto pb-2">
                            <button
                                onClick={() => onFilterChange('period', 'today')}
                                className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap ${filters.period === 'today' ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600'}`}
                            >
                                Hoy
                            </button>
                            <button
                                onClick={() => onFilterChange('period', 'week')}
                                className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap ${filters.period === 'week' ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600'}`}
                            >
                                Esta semana
                            </button>
                            <button
                                onClick={() => onFilterChange('period', 'month')}
                                className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap ${filters.period === 'month' ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600'}`}
                            >
                                Este mes
                            </button>
                            <button
                                onClick={() => onFilterChange('period', 'all')}
                                className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap ${filters.period === 'all' ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600'}`}
                            >
                                Todos
                            </button>
                        </div>
                        
                        {/* Filtros avanzados */}
                        {showAdvanced && (
                            <div className="grid grid-cols-2 gap-3 pt-3 border-t border-slate-100 animate-in slide-in-from-top">
                                <div>
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">Veh√≠culo</label>
                                    <select
                                        value={filters.vehicle || ''}
                                        onChange={(e) => onFilterChange('vehicle', e.target.value)}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                    >
                                        <option value="">Todos</option>
                                        {availableVehicles.map(v => (
                                            <option key={v.id} value={v.id}>{v.label}</option>
                                        ))}
                                    </select>
                                </div>
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">Categor√≠a</label>
                                    <select
                                        value={filters.category || ''}
                                        onChange={(e) => onFilterChange('category', e.target.value)}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                    >
                                        <option value="">Todas</option>
                                        {availableCategories.map(c => (
                                            <option key={c} value={c}>{c}</option>
                                        ))}
                                    </select>
                                </div>
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">M√©todo de Pago</label>
                                    <select
                                        value={filters.paymentMethod || ''}
                                        onChange={(e) => onFilterChange('paymentMethod', e.target.value)}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                    >
                                        <option value="">Todos</option>
                                        {availablePaymentMethods.map(m => (
                                            <option key={m.id} value={m.id}>{m.label}</option>
                                        ))}
                                    </select>
                                </div>
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">Tipo</label>
                                    <select
                                        value={filters.expenseType || ''}
                                        onChange={(e) => onFilterChange('expenseType', e.target.value)}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                    >
                                        <option value="">Ambos</option>
                                        <option value="Personal">Personal</option>
                                        <option value="Empresa">Empresa</option>
                                    </select>
                                </div>
                                
                                {/* Rango de fechas */}
                                <div className="col-span-2">
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">Rango de Fechas</label>
                                    <div className="flex gap-2">
                                        <input
                                            type="date"
                                            value={filters.startDate || ''}
                                            onChange={(e) => onFilterChange('startDate', e.target.value)}
                                            className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                        />
                                        <span className="self-center text-slate-400">a</span>
                                        <input
                                            type="date"
                                            value={filters.endDate || ''}
                                            onChange={(e) => onFilterChange('endDate', e.target.value)}
                                            className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                        />
                                    </div>
                                </div>
                                
                                {/* Rango de montos */}
                                <div className="col-span-2">
                                    <label className="text-xs font-bold text-slate-500 mb-1 block">Rango de Montos</label>
                                    <div className="flex gap-2">
                                        <input
                                            type="number"
                                            placeholder="M√≠n"
                                            value={filters.minAmount || ''}
                                            onChange={(e) => onFilterChange('minAmount', e.target.value)}
                                            className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                        />
                                        <span className="self-center text-slate-400">a</span>
                                        <input
                                            type="number"
                                            placeholder="M√°x"
                                            value={filters.maxAmount || ''}
                                            onChange={(e) => onFilterChange('maxAmount', e.target.value)}
                                            className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-700"
                                        />
                                    </div>
                                </div>
                                
                                {/* Botones de acci√≥n */}
                                <div className="col-span-2 flex gap-2 pt-2">
                                    <button
                                        onClick={() => {
                                            // Resetear todos los filtros
                                            onFilterChange('reset', true);
                                        }}
                                        className="flex-1 bg-slate-100 text-slate-600 py-2 rounded-lg font-medium text-sm hover:bg-slate-200"
                                    >
                                        Limpiar Filtros
                                    </button>
                                    <button
                                        onClick={() => setShowAdvanced(false)}
                                        className="flex-1 bg-blue-600 text-white py-2 rounded-lg font-medium text-sm hover:bg-blue-700"
                                    >
                                        Aplicar
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        // Componente de Estad√≠sticas (memoizado)
        const StatsDashboard = memo(({ trips, expenses, filters }) => {
            const stats = useMemo(() => {
                if (!trips.length && !expenses.length) return null;
                
                const filteredTrips = trips.filter(trip => {
                    if (filters.period === 'today') {
                        const today = new Date().toLocaleDateString();
                        return trip.date === today;
                    }
                    if (filters.period === 'week') {
                        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toLocaleDateString();
                        return new Date(trip.date) >= new Date(weekAgo);
                    }
                    if (filters.period === 'month') {
                        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toLocaleDateString();
                        return new Date(trip.date) >= new Date(monthAgo);
                    }
                    return true;
                });
                
                const filteredExpenses = expenses.filter(expense => {
                    if (filters.period === 'today') {
                        const today = new Date().toLocaleDateString();
                        return expense.date === today;
                    }
                    if (filters.period === 'week') {
                        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toLocaleDateString();
                        return new Date(expense.date) >= new Date(weekAgo);
                    }
                    if (filters.period === 'month') {
                        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toLocaleDateString();
                        return new Date(expense.date) >= new Date(monthAgo);
                    }
                    return true;
                });
                
                const totalDistance = filteredTrips.reduce((sum, trip) => sum + (trip.distance || 0), 0);
                const totalExpenses = filteredExpenses.reduce((sum, exp) => sum + (exp.amount || 0), 0);
                const avgDistance = filteredTrips.length ? totalDistance / filteredTrips.length : 0;
                const avgExpense = filteredExpenses.length ? totalExpenses / filteredExpenses.length : 0;
                
                // Gastos por categor√≠a
                const expensesByCategory = filteredExpenses.reduce((acc, exp) => {
                    acc[exp.category] = (acc[exp.category] || 0) + exp.amount;
                    return acc;
                }, {});
                
                // Gastos por veh√≠culo
                const expensesByVehicle = {};
                filteredTrips.forEach(trip => {
                    trip.expenses?.forEach(exp => {
                        expensesByVehicle[trip.vehicle] = (expensesByVehicle[trip.vehicle] || 0) + exp.amount;
                    });
                });
                
                return {
                    totalTrips: filteredTrips.length,
                    totalExpenses: filteredExpenses.length,
                    totalDistance,
                    totalExpenseAmount: totalExpenses,
                    avgDistance,
                    avgExpense,
                    expensesByCategory,
                    expensesByVehicle
                };
            }, [trips, expenses, filters.period]);
            
            if (!stats) return null;
            
            return (
                <div className="bg-white rounded-xl p-4 shadow-sm border border-slate-100 mb-4">
                    <h3 className="font-bold text-slate-700 mb-4 flex items-center">
                        <Icon name="BarChart" size={18} className="mr-2 text-blue-500"/> Estad√≠sticas
                    </h3>
                    
                    <div className="grid grid-cols-2 gap-3">
                        <div className="bg-blue-50 p-3 rounded-lg">
                            <div className="text-sm text-blue-700 font-medium">Viajes</div>
                            <div className="text-2xl font-bold text-blue-900">{stats.totalTrips}</div>
                            <div className="text-xs text-blue-600">{stats.totalDistance} km totales</div>
                        </div>
                        
                        <div className="bg-emerald-50 p-3 rounded-lg">
                            <div className="text-sm text-emerald-700 font-medium">Gastos</div>
                            <div className="text-2xl font-bold text-emerald-900">{stats.totalExpenses}</div>
                            <div className="text-xs text-emerald-600">${stats.totalExpenseAmount.toFixed(2)} total</div>
                        </div>
                        
                        <div className="bg-violet-50 p-3 rounded-lg">
                            <div className="text-sm text-violet-700 font-medium">Prom. Viaje</div>
                            <div className="text-2xl font-bold text-violet-900">{stats.avgDistance.toFixed(1)}</div>
                            <div className="text-xs text-violet-600">km por viaje</div>
                        </div>
                        
                        <div className="bg-amber-50 p-3 rounded-lg">
                            <div className="text-sm text-amber-700 font-medium">Prom. Gasto</div>
                            <div className="text-2xl font-bold text-amber-900">${stats.avgExpense.toFixed(2)}</div>
                            <div className="text-xs text-amber-600">por gasto</div>
                        </div>
                    </div>
                    
                    {/* Gr√°fico simple de categor√≠as */}
                    {Object.keys(stats.expensesByCategory).length > 0 && (
                        <div className="mt-4 pt-4 border-t border-slate-100">
                            <h4 className="text-sm font-medium text-slate-600 mb-2">Gastos por Categor√≠a</h4>
                            <div className="space-y-2">
                                {Object.entries(stats.expensesByCategory)
                                    .sort((a, b) => b[1] - a[1])
                                    .slice(0, 3)
                                    .map(([category, amount]) => {
                                        const percentage = (amount / stats.totalExpenseAmount) * 100;
                                        return (
                                            <div key={category} className="space-y-1">
                                                <div className="flex justify-between text-sm">
                                                    <span className="text-slate-700">{category}</span>
                                                    <span className="font-medium">${amount.toFixed(2)}</span>
                                                </div>
                                                <div className="h-2 bg-slate-100 rounded-full overflow-hidden">
                                                    <div 
                                                        className="h-full bg-blue-500 rounded-full"
                                                        style={{ width: `${Math.min(percentage, 100)}%` }}
                                                    />
                                                </div>
                                            </div>
                                        );
                                    })}
                            </div>
                        </div>
                    )}
                </div>
            );
        });

        // ==========================================
        // 6. HOOKS PERSONALIZADOS PARA OPTIMIZACI√ìN
        // ==========================================

        // Hook para filtrado memoizado
        const useFilteredData = (data, filters, dataType) => {
            return useMemo(() => {
                if (!data || !data.length) return [];
                
                return data.filter(item => {
                    // Filtro de b√∫squeda
                    if (filters.search) {
                        const searchLower = filters.search.toLowerCase();
                        if (dataType === 'trips') {
                            const matchesOrigin = item.origin?.toLowerCase().includes(searchLower);
                            const matchesDestination = item.destination?.toLowerCase().includes(searchLower);
                            const matchesVehicle = getVehicleInfo(item.vehicle).label.toLowerCase().includes(searchLower);
                            if (!(matchesOrigin || matchesDestination || matchesVehicle)) return false;
                        } else if (dataType === 'expenses') {
                            const matchesCategory = item.category?.toLowerCase().includes(searchLower);
                            const matchesNotes = item.notes?.toLowerCase().includes(searchLower);
                            if (!(matchesCategory || matchesNotes)) return false;
                        } else if (dataType === 'visits') {
                            const matchesClient = item.client?.toLowerCase().includes(searchLower);
                            if (!matchesClient) return false;
                        }
                    }
                    
                    // Filtro por veh√≠culo
                    if (filters.vehicle && item.vehicle !== filters.vehicle) {
                        return false;
                    }
                    
                    // Filtro por categor√≠a
                    if (filters.category && item.category !== filters.category) {
                        return false;
                    }
                    
                    // Filtro por m√©todo de pago
                    if (filters.paymentMethod && item.method !== filters.paymentMethod) {
                        return false;
                    }
                    
                    // Filtro por tipo de gasto
                    if (filters.expenseType && item.type !== filters.expenseType) {
                        return false;
                    }
                    
                    // Filtro por rango de fechas
                    if (filters.startDate || filters.endDate) {
                        const itemDate = new Date(item.date);
                        if (filters.startDate && itemDate < new Date(filters.startDate)) return false;
                        if (filters.endDate && itemDate > new Date(filters.endDate)) return false;
                    }
                    
                    // Filtro por rango de montos
                    if (filters.minAmount && item.amount < parseFloat(filters.minAmount)) return false;
                    if (filters.maxAmount && item.amount > parseFloat(filters.maxAmount)) return false;
                    
                    // Filtro por per√≠odo
                    if (filters.period && filters.period !== 'all') {
                        const itemDate = new Date(item.date);
                        const now = new Date();
                        
                        if (filters.period === 'today') {
                            const today = new Date().toLocaleDateString();
                            return item.date === today;
                        } else if (filters.period === 'week') {
                            const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                            return itemDate >= weekAgo;
                        } else if (filters.period === 'month') {
                            const monthAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
                            return itemDate >= monthAgo;
                        }
                    }
                    
                    return true;
                }).sort((a, b) => {
                    // Ordenar por fecha m√°s reciente primero
                    return new Date(b.date) - new Date(a.date);
                });
            }, [data, filters, dataType]);
        };

        // Hook para c√°lculos estad√≠sticos memoizados
        const useStatistics = (trips, expenses) => {
            return useMemo(() => {
                const totalDistance = trips.reduce((sum, trip) => sum + (trip.distance || 0), 0);
                const totalExpenses = expenses.reduce((sum, exp) => sum + (exp.amount || 0), 0);
                
                // Gastos por categor√≠a
                const categoryBreakdown = expenses.reduce((acc, exp) => {
                    acc[exp.category] = (acc[exp.category] || 0) + exp.amount;
                    return acc;
                }, {});
                
                // Gastos por veh√≠culo
                const vehicleBreakdown = {};
                trips.forEach(trip => {
                    trip.expenses?.forEach(exp => {
                        vehicleBreakdown[trip.vehicle] = (vehicleBreakdown[trip.vehicle] || 0) + exp.amount;
                    });
                });
                
                // Gastos por mes
                const monthlyBreakdown = expenses.reduce((acc, exp) => {
                    const date = new Date(exp.date);
                    const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    acc[monthYear] = (acc[monthYear] || 0) + exp.amount;
                    return acc;
                }, {});
                
                return {
                    totalDistance,
                    totalExpenses,
                    avgDistance: trips.length ? totalDistance / trips.length : 0,
                    avgExpense: expenses.length ? totalExpenses / expenses.length : 0,
                    categoryBreakdown,
                    vehicleBreakdown,
                    monthlyBreakdown
                };
            }, [trips, expenses]);
        };

        // ==========================================
        // 7. FUNCIONES DE EXPORTACI√ìN MEJORADAS
        // ==========================================

        const exportData = {
            // Exportar a JSON
            toJSON: (data, filename) => {
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename || 'export.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                return true;
            },
            
            // Exportar a CSV
            toCSV: (data, columns, filename) => {
                // Convertir array de objetos a CSV
                const headers = columns.map(col => `"${col.label}"`).join(',');
                const rows = data.map(row => 
                    columns.map(col => {
                        const value = row[col.key];
                        // Manejar valores que contienen comas o comillas
                        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                            return `"${value.replace(/"/g, '""')}"`;
                        }
                        return `"${value}"`;
                    }).join(',')
                ).join('\n');
                
                const csv = `${headers}\n${rows}`;
                const dataBlob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename || 'export.csv';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                return true;
            },
            
            // Exportar viajes a CSV
            exportTripsCSV: (trips) => {
                const columns = [
                    { key: 'date', label: 'Fecha' },
                    { key: 'origin', label: 'Origen' },
                    { key: 'destination', label: 'Destino' },
                    { key: 'distance', label: 'Distancia (km)' },
                    { key: 'startTime', label: 'Hora Inicio' },
                    { key: 'endTime', label: 'Hora Fin' },
                    { key: 'vehicle', label: 'Veh√≠culo' },
                    { key: 'startOdometer', label: 'Od√≥metro Inicio' },
                    { key: 'endOdometer', label: 'Od√≥metro Fin' }
                ];
                
                return exportData.toCSV(trips, columns, `viajes_${new Date().toISOString().split('T')[0]}.csv`);
            },
            
            // Exportar gastos a CSV
            exportExpensesCSV: (expenses) => {
                const columns = [
                    { key: 'date', label: 'Fecha' },
                    { key: 'time', label: 'Hora' },
                    { key: 'category', label: 'Categor√≠a' },
                    { key: 'amount', label: 'Monto' },
                    { key: 'currency', label: 'Moneda' },
                    { key: 'type', label: 'Tipo' },
                    { key: 'method', label: 'M√©todo de Pago' },
                    { key: 'notes', label: 'Notas' },
                    { key: 'odometer', label: 'Od√≥metro' },
                    { key: 'volume', label: 'Volumen' }
                ];
                
                return exportData.toCSV(expenses, columns, `gastos_${new Date().toISOString().split('T')[0]}.csv`);
            },
            
            // Exportar reporte completo
            exportFullReport: (trips, expenses, visits, statistics) => {
                const report = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        version: '2.0.0',
                        totalTrips: trips.length,
                        totalExpenses: expenses.length,
                        totalVisits: visits.length
                    },
                    statistics: {
                        totalDistance: statistics.totalDistance,
                        totalExpenses: statistics.totalExpenses,
                        avgDistance: statistics.avgDistance,
                        avgExpense: statistics.avgExpense,
                        categoryBreakdown: statistics.categoryBreakdown,
                        vehicleBreakdown: statistics.vehicleBreakdown
                    },
                    trips,
                    expenses,
                    visits
                };
                
                return exportData.toJSON(report, `reporte_completo_${new Date().toISOString().split('T')[0]}.json`);
            },
            
            // Exportar para contabilidad
            exportAccountingReport: (expenses) => {
                const accountingData = expenses.map(exp => ({
                    Fecha: exp.date,
                    Comprobante: `GST-${exp.id}`,
                    Descripci√≥n: exp.category,
                    'Tipo de Gasto': exp.type === 'Empresa' ? 'Empresa' : 'Personal',
                    Categor√≠a: exp.category,
                    'M√©todo de Pago': PAYMENT_METHODS.find(m => m.id === exp.method)?.label || exp.method,
                    'Monto $': exp.currency === 'U$D' ? exp.amount : '',
                    'Monto UYU': exp.currency === 'UYU' ? exp.amount : '',
                    Observaciones: exp.notes || ''
                }));
                
                const columns = [
                    { key: 'Fecha', label: 'Fecha' },
                    { key: 'Comprobante', label: 'Comprobante' },
                    { key: 'Descripci√≥n', label: 'Descripci√≥n' },
                    { key: 'Tipo de Gasto', label: 'Tipo de Gasto' },
                    { key: 'Categor√≠a', label: 'Categor√≠a' },
                    { key: 'M√©todo de Pago', label: 'M√©todo de Pago' },
                    { key: 'Monto $', label: 'Monto $' },
                    { key: 'Monto UYU', label: 'Monto UYU' },
                    { key: 'Observaciones', label: 'Observaciones' }
                ];
                
                return exportData.toCSV(accountingData, columns, `reporte_contable_${new Date().toISOString().split('T')[0]}.csv`);
            }
        };

        // ==========================================
        // 8. COMPONENTE PRINCIPAL APP (OPTIMIZADO)
        // ==========================================

        const App = () => {
            // --- ESTADO PRINCIPAL (MEMOIZADO) ---
            const [appState, setAppState] = useState('IDLE');
            const [historyTab, setHistoryTab] = useState('TRIPS');
            const [dataLoaded, setDataLoaded] = useState(false);
            const [toastMessage, setToastMessage] = useState(null);

            // Estado de datos
            const [vehicleOdometers, setVehicleOdometers] = useState({
                PERSONAL: 10500,
                COMPANY_FUEL: 45200,
                COMPANY_ELECTRIC: 5000,
                OTHER: 0
            });
            
            const [lastLocation, setLastLocation] = useState('Casa');
            const [trips, setTrips] = useState([]);
            const [expenses, setExpenses] = useState([]);
            const [visits, setVisits] = useState([]);

            const [dashboardVehicleId, setDashboardVehicleId] = useState('PERSONAL');

            // Estado de filtros (nuevo)
            const [filters, setFilters] = useState({
                search: '',
                period: 'all',
                vehicle: '',
                category: '',
                paymentMethod: '',
                expenseType: '',
                startDate: '',
                endDate: '',
                minAmount: '',
                maxAmount: ''
            });

            // Modales
            const [showLocationSelector, setShowLocationSelector] = useState(false);
            const [showOdometerEditor, setShowOdometerEditor] = useState(false);
            const [showVehicleSelector, setShowVehicleSelector] = useState(false);
            const [showExpenseCategorySelector, setShowExpenseCategorySelector] = useState(false);
            const [showDestinationModal, setShowDestinationModal] = useState(false); 
            const [showSaveConfirmation, setShowSaveConfirmation] = useState(false);
            const [showParkingAskModal, setShowParkingAskModal] = useState(false);
            const [showChargeTypeModal, setShowChargeTypeModal] = useState(false);
            const [showUpdatePrompt, setShowUpdatePrompt] = useState(false);
            const [showExportModal, setShowExportModal] = useState(false); // Nuevo modal de exportaci√≥n

            const [editingTrip, setEditingTrip] = useState(null);
            const [editingVisit, setEditingVisit] = useState(null);
            
            const [locationSelectorMode, setLocationSelectorMode] = useState('ORIGIN'); 
            const [textModalTitle, setTextModalTitle] = useState('Nombre del Cliente');
            const [pendingStartData, setPendingStartData] = useState(null);

            // Configs
            const [vehicleConfigs, setVehicleConfigs] = useState({
                PERSONAL: { tollPrice: '162.00', fuelPrice: '78.02', kmValue: '15.00', currency: 'UYU' },
                COMPANY_FUEL: { tollPrice: '162.00', fuelPrice: '78.02', kmValue: '12.00', currency: 'UYU' },
                COMPANY_ELECTRIC: { tollPrice: '162.00', fuelPriceAC: '9.50', fuelPriceDC: '10.80', kmValue: '4.00', currency: 'UYU' },
                OTHER: { tollPrice: '162.00', fuelPrice: '78.02', kmValue: '20.00', currency: 'UYU' }
            });

            const [editingVehicleId, setEditingVehicleId] = useState('PERSONAL');

            const [currentTrip, setCurrentTrip] = useState({
                startTime: null,
                vehicle: 'PERSONAL',
                origin: '',
                destination: '', 
                startOdometer: 0,
                tripExpenses: []
            });

            const [expenseModalData, setExpenseModalData] = useState({
                isOpen: false,
                id: null,
                category: '', 
                amount: '',
                currency: 'UYU',
                currencyType: 'UYU', 
                method: 'EFECTIVO',
                type: 'Personal',
                notes: '',
                odometer: '',
                volume: ''
            });

            const [inputOdometer, setInputOdometer] = useState('');
            const [inputDestination, setInputDestination] = useState(''); 
            const [showGapAlert, setShowGapAlert] = useState(false);
            const [gapKm, setGapKm] = useState(0);
            const [elapsedTime, setElapsedTime] = useState(0);

            // --- HOOKS PERSONALIZADOS ---
            
            // Calcular estad√≠sticas memoizadas
            const statistics = useStatistics(trips, expenses);
            
            // Datos filtrados memoizados
            const filteredTrips = useFilteredData(trips, filters, 'trips');
            const filteredExpenses = useFilteredData(expenses, filters, 'expenses');
            const filteredVisits = useFilteredData(visits, filters, 'visits');
            
            // Categor√≠as √∫nicas para filtros
            const uniqueCategories = useMemo(() => {
                const categories = [...new Set(expenses.map(e => e.category))];
                return categories.sort();
            }, [expenses]);

            // --- EFECTOS ---

            // Cargar datos iniciales
            useEffect(() => {
                const loadData = async () => {
                    try {
                        console.log("üìÇ Cargando datos desde IndexedDB...");
                        
                        const [tripsData, expensesData, visitsData, settingsData] = await Promise.all([
                            dbHelper.get('trips'),
                            dbHelper.get('expenses'),
                            dbHelper.get('visits'),
                            dbHelper.get('settings', 'odometers')
                        ]);
                        
                        // Cargar datos con validaci√≥n
                        if (tripsData && Array.isArray(tripsData)) {
                            console.log(`‚úÖ Cargados ${tripsData.length} viajes`);
                            setTrips(tripsData);
                        }
                        
                        if (expensesData && Array.isArray(expensesData)) {
                            console.log(`‚úÖ Cargados ${expensesData.length} gastos`);
                            setExpenses(expensesData);
                        }
                        
                        if (visitsData && Array.isArray(visitsData)) {
                            console.log(`‚úÖ Cargados ${visitsData.length} visitas`);
                            setVisits(visitsData);
                        }
                        
                        if (settingsData) {
                            console.log("‚úÖ Cargadas configuraciones");
                            // Cargar od√≥metros desde settings
                            if (settingsData.odometers) {
                                setVehicleOdometers(settingsData.odometers);
                            }
                            if (settingsData.configs) {
                                setVehicleConfigs(settingsData.configs);
                            }
                            if (settingsData.lastLocation) {
                                setLastLocation(settingsData.lastLocation);
                            }
                        }
                        
                        setDataLoaded(true);
                        console.log("üéâ Todos los datos cargados correctamente");
                        
                    } catch (error) {
                        console.error("‚ùå Error cargando datos:", error);
                        setToastMessage({ 
                            type: 'error', 
                            message: 'Error cargando datos. Usando valores por defecto.' 
                        });
                        setDataLoaded(true);
                    }
                };
                
                loadData();
            }, []);

            // Guardar datos autom√°ticamente (debounced)
            useEffect(() => {
                if (!dataLoaded) return;
                
                const saveData = async () => {
                    try {
                        await Promise.all([
                            dbHelper.set('trips', trips),
                            dbHelper.set('expenses', expenses),
                            dbHelper.set('visits', visits),
                            dbHelper.set('settings', {
                                odometers: vehicleOdometers,
                                configs: vehicleConfigs,
                                lastLocation: lastLocation
                            })
                        ]);
                        console.log("üíæ Datos guardados autom√°ticamente");
                    } catch (error) {
                        console.error("Error guardando datos:", error);
                    }
                };
                
                // Debounce para evitar guardados frecuentes
                const timeoutId = setTimeout(saveData, 2000);
                return () => clearTimeout(timeoutId);
            }, [trips, expenses, visits, vehicleOdometers, vehicleConfigs, lastLocation, dataLoaded]);

            // Timer para viaje activo
            useEffect(() => {
                let interval;
                if (appState === 'ACTIVE') {
                    interval = setInterval(() => setElapsedTime(prev => prev + 1), 1000);
                } else {
                    setElapsedTime(0);
                }
                return () => clearInterval(interval);
            }, [appState]);

            // --- FUNCIONES MEMOIZADAS ---
            
            const getVehicleInfo = useCallback((id) => {
                return VEHICLE_TYPES.find(v => v.id === id) || VEHICLE_TYPES[0];
            }, []);
            
            const formatMoney = useCallback((amount) => {
                return Number(amount || 0).toFixed(2);
            }, []);
            
            const formatTime = useCallback((seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }, []);
            
            const getActiveConfig = useCallback(() => {
                const vId = (appState === 'ACTIVE' || appState === 'ENDING' || appState === 'STARTING') && currentTrip.vehicle 
                    ? currentTrip.vehicle 
                    : dashboardVehicleId; 
                return vehicleConfigs[vId] || vehicleConfigs['PERSONAL'];
            }, [appState, currentTrip.vehicle, dashboardVehicleId, vehicleConfigs]);

            // --- MANEJO DE FILTROS ---
            
            const handleFilterChange = useCallback((key, value) => {
                if (key === 'reset') {
                    setFilters({
                        search: '',
                        period: 'all',
                        vehicle: '',
                        category: '',
                        paymentMethod: '',
                        expenseType: '',
                        startDate: '',
                        endDate: '',
                        minAmount: '',
                        maxAmount: ''
                    });
                } else {
                    setFilters(prev => ({
                        ...prev,
                        [key]: value
                    }));
                }
            }, []);

            // --- FUNCIONES PRINCIPALES ---
            
            const handleUpdateRates = useCallback(() => {
                const updatedConfigs = { ...vehicleConfigs };
                Object.keys(updatedConfigs).forEach(key => {
                    updatedConfigs[key].tollPrice = OFFICIAL_RATES.toll;
                    if(updatedConfigs[key].fuelPrice) updatedConfigs[key].fuelPrice = OFFICIAL_RATES.fuel;
                    if(updatedConfigs[key].fuelPriceAC) updatedConfigs[key].fuelPriceAC = OFFICIAL_RATES.electricAC;
                    if(updatedConfigs[key].fuelPriceDC) updatedConfigs[key].fuelPriceDC = OFFICIAL_RATES.electricDC;
                });
                setVehicleConfigs(updatedConfigs);
                setShowUpdatePrompt(false);
                setToastMessage({ type: 'success', message: 'Tarifas actualizadas correctamente' });
            }, [vehicleConfigs]);

            const handleChargeTypeSelection = useCallback((type) => {
                setShowChargeTypeModal(false);
                const activeConfig = getActiveConfig();
                let price = 0;
                
                if (type === 'AC') price = parseFloat(activeConfig.fuelPriceAC || 0);
                else if (type === 'DC') price = parseFloat(activeConfig.fuelPriceDC || 0);

                openExpenseModal('Carga El√©ctrica', formatMoney(price));
            }, [getActiveConfig, formatMoney]);

            const openExpenseModal = useCallback((category, amountOverride = null, expenseToEdit = null) => {
                const currentVId = (appState === 'ACTIVE' || appState === 'ENDING' || appState === 'STARTING') ? currentTrip.vehicle : dashboardVehicleId;
                const currentOdo = vehicleOdometers[currentVId] || 0;

                if (expenseToEdit) {
                    setExpenseModalData({
                        isOpen: true,
                        id: expenseToEdit.id,
                        category: expenseToEdit.category,
                        amount: expenseToEdit.amount,
                        currency: expenseToEdit.currency,
                        currencyType: expenseToEdit.currencyType || expenseToEdit.currency,
                        method: expenseToEdit.method,
                        type: expenseToEdit.type,
                        notes: expenseToEdit.notes || '',
                        odometer: expenseToEdit.odometer || currentOdo,
                        volume: expenseToEdit.volume || ''
                    });
                } else {
                    const activeConfig = getActiveConfig();
                    const isCompanyVehicle = currentVId.includes('COMPANY');

                    let defaults = { amount: '', currency: 'UYU', method: 'CREDITO', type: isCompanyVehicle ? 'Empresa' : 'Empresa' };

                    if (category === 'Peaje') {
                        defaults = { amount: formatMoney(activeConfig.tollPrice), currency: activeConfig.currency, method: 'DEBITO', type: 'Personal' };
                    } else if (['Carga Combustible', 'Combustible'].includes(category)) {
                        defaults = { amount: formatMoney(activeConfig.fuelPrice || ''), currency: activeConfig.currency, method: 'CREDITO', type: 'Personal' };
                    } else if (category === 'Carga El√©ctrica') {
                        defaults = { amount: amountOverride !== null ? amountOverride : '', currency: activeConfig.currency, method: 'CREDITO', type: 'Personal' };
                    }

                    const isStandardCurrency = ['UYU', 'U$D'].includes(defaults.currency);
                    
                    setExpenseModalData({
                        isOpen: true,
                        id: null,
                        category,
                        amount: defaults.amount,
                        currency: defaults.currency,
                        currencyType: isStandardCurrency ? defaults.currency : 'Otro',
                        method: defaults.method,
                        type: defaults.type,
                        notes: '',
                        odometer: currentOdo,
                        volume: ''
                    });
                }
                setShowExpenseCategorySelector(false);
            }, [appState, currentTrip.vehicle, dashboardVehicleId, vehicleOdometers, getActiveConfig, formatMoney]);

            const confirmExpense = useCallback(() => {
                // Validaciones
                const amount = parseFloat(expenseModalData.amount);
                if (isNaN(amount) || amount <= 0) {
                    setToastMessage({ type: 'error', message: 'Ingrese un monto v√°lido y mayor a 0' });
                    return;
                }
                
                const isCharge = ['Carga Combustible', 'Carga El√©ctrica'].includes(expenseModalData.category);
                if (isCharge) {
                    const volume = parseFloat(expenseModalData.volume);
                    const odometer = parseInt(expenseModalData.odometer);
                    
                    if (isNaN(volume) || volume <= 0) {
                        setToastMessage({ 
                            type: 'error', 
                            message: `Ingrese un volumen v√°lido (${expenseModalData.category.includes('El√©ctrica') ? 'kWh' : 'Litros'})` 
                        });
                        return;
                    }
                    
                    if (isNaN(odometer) || odometer < 0) {
                        setToastMessage({ type: 'error', message: 'Ingrese un od√≥metro v√°lido' });
                        return;
                    }
                }

                // Actualizar od√≥metro si es carga
                const currentVId = (appState === 'ACTIVE' || appState === 'ENDING' || appState === 'STARTING') ? currentTrip.vehicle : dashboardVehicleId;
                
                if (isCharge && expenseModalData.odometer) {
                    const newOdo = parseInt(expenseModalData.odometer);
                    if (!isNaN(newOdo) && newOdo > vehicleOdometers[currentVId]) {
                        setVehicleOdometers(prev => ({ ...prev, [currentVId]: newOdo }));
                    }
                }

                if (expenseModalData.id) {
                    // Edici√≥n
                     setExpenses(prev => prev.map(e => e.id === expenseModalData.id ? {
                        ...e,
                        category: expenseModalData.category,
                        amount: parseFloat(expenseModalData.amount) || 0,
                        currency: expenseModalData.currency,
                        method: expenseModalData.method,
                        type: expenseModalData.type,
                        notes: expenseModalData.notes,
                        odometer: expenseModalData.odometer,
                        volume: expenseModalData.volume
                    } : e));
                    setExpenseModalData({ ...expenseModalData, isOpen: false });
                    setToastMessage({ type: 'success', message: 'Gasto actualizado' });
                } else {
                    // Nuevo
                    const newExpense = {
                        id: Date.now(),
                        date: new Date().toLocaleDateString(),
                        time: new Date().toLocaleTimeString(),
                        category: expenseModalData.category,
                        amount: parseFloat(expenseModalData.amount) || 0,
                        currency: expenseModalData.currency, 
                        method: expenseModalData.method,
                        type: expenseModalData.type,
                        notes: expenseModalData.notes,
                        odometer: expenseModalData.odometer,
                        volume: expenseModalData.volume,
                        tripId: currentTrip.startTime ? (typeof currentTrip.startTime.getTime === 'function' ? currentTrip.startTime.getTime() : Date.now()) : 'loose_expense'
                    };

                    if (['ACTIVE', 'ENDING', 'STARTING'].includes(appState)) {
                        setCurrentTrip(prev => ({
                            ...prev,
                            tripExpenses: [...prev.tripExpenses, newExpense]
                        }));
                    }
                    setExpenses(prev => [newExpense, ...prev]);
                    setExpenseModalData({ ...expenseModalData, isOpen: false });
                    setToastMessage({ type: 'success', message: 'Gasto registrado' });

                    // Check for pending start trip
                    if (appState === 'STARTING' && pendingStartData) {
                        startTripProcess(pendingStartData.odo, pendingStartData.dest);
                        setPendingStartData(null);
                    }
                }
            }, [expenseModalData, appState, currentTrip, dashboardVehicleId, vehicleOdometers, pendingStartData]);

            const deleteExpense = useCallback(() => {
                if (expenseModalData.id) {
                    setExpenses(prev => prev.filter(e => e.id !== expenseModalData.id));
                    setExpenseModalData({ ...expenseModalData, isOpen: false });
                    setToastMessage({ type: 'success', message: 'Gasto eliminado' });
                }
            }, [expenseModalData]);

            const updateDashboardOdometer = useCallback((newVal) => {
                const val = parseInt(newVal);
                if (!isNaN(val)) {
                    setVehicleOdometers(prev => ({ ...prev, [dashboardVehicleId]: val }));
                    setToastMessage({ type: 'success', message: 'Od√≥metro actualizado' });
                }
                setShowOdometerEditor(false);
            }, [dashboardVehicleId]);

            const handleStartPress = useCallback(() => {
                const currentOdo = vehicleOdometers[dashboardVehicleId];
                setInputOdometer(currentOdo.toString());
                setInputDestination('');
                setCurrentTrip({
                    startTime: null,
                    vehicle: dashboardVehicleId,
                    origin: lastLocation,
                    destination: '', 
                    startOdometer: 0,
                    tripExpenses: [] 
                });
                setAppState('STARTING');
            }, [vehicleOdometers, dashboardVehicleId, lastLocation]);

            const confirmStartTrip = useCallback((destinationOverride = undefined) => {
                const inputOdoVal = parseInt(inputOdometer) || 0;
                const currentVehicleOdo = vehicleOdometers[currentTrip.vehicle];
                
                // Validaci√≥n de od√≥metro
                if (!VALIDATORS.odometer(inputOdoVal)) {
                    setToastMessage({ type: 'error', message: 'Od√≥metro inicial inv√°lido' });
                    return;
                }
                
                if (inputOdoVal > currentVehicleOdo) {
                    setGapKm(inputOdoVal - currentVehicleOdo);
                    setShowGapAlert(true);
                    if (destinationOverride) setInputDestination(destinationOverride);
                    return;
                }
                
                // Parking Check Logic
                const isOriginClient = lastLocation.toLowerCase().includes('cliente') || ['Otra', 'Otro'].includes(lastLocation);
                const hasParkingExpense = currentTrip.tripExpenses.some(e => e.category === 'Estacionamiento');

                if (isOriginClient && !hasParkingExpense) {
                   setPendingStartData({ odo: inputOdoVal, dest: destinationOverride });
                   setShowParkingAskModal(true);
                   return;
                }

                startTripProcess(inputOdoVal, destinationOverride);
            }, [inputOdometer, vehicleOdometers, currentTrip, lastLocation]);

            const startTripProcess = useCallback((startOdo, destinationOverride = undefined) => {
                setCurrentTrip(prev => ({
                    ...prev,
                    startTime: new Date(),
                    origin: lastLocation,
                    destination: destinationOverride !== undefined ? destinationOverride : inputDestination, 
                    startOdometer: startOdo,
                }));
                setAppState('ACTIVE');
                setToastMessage({ type: 'success', message: 'Viaje iniciado' });
            }, [lastLocation, inputDestination]);

            const handleArrivePress = useCallback(() => {
                const currentVehicleOdo = vehicleOdometers[currentTrip.vehicle] || 0;
                const startOdo = parseInt(currentTrip.startOdometer) || 0;
                const lastKnown = Math.max(currentVehicleOdo, startOdo);
                
                setInputOdometer((lastKnown + 1).toString());

                if (currentTrip.destination) {
                    setInputDestination(currentTrip.destination);
                } else {
                    setInputDestination('');
                }
                setAppState('ENDING');
            }, [vehicleOdometers, currentTrip]);

            const confirmEndTrip = useCallback(() => {
                const endOdo = parseInt(inputOdometer) || 0;
                const startOdo = currentTrip.startOdometer || 0;
                const distance = endOdo - startOdo;
                
                // Validaciones mejoradas
                if (endOdo < startOdo) {
                    setToastMessage({
                        type: 'error',
                        message: `Error: Od√≥metro final (${endOdo}) menor al inicial (${startOdo})`
                    });
                    return;
                }
                
                if (distance < 0) {
                    setToastMessage({ type: 'error', message: 'Error: Distancia calculada negativa' });
                    return;
                }
                
                if (!inputDestination || inputDestination.trim() === '') {
                    setToastMessage({ type: 'error', message: 'Debe especificar un destino' });
                    return;
                }
                
                if (!VALIDATORS.odometer(endOdo)) {
                    setToastMessage({ type: 'error', message: 'Od√≥metro final inv√°lido' });
                    return;
                }
                
                const safeStartTime = currentTrip.startTime instanceof Date ? currentTrip.startTime : new Date();
                const safeEndTime = new Date();

                const newTrip = {
                    id: Date.now(),
                    date: safeEndTime.toLocaleDateString(),
                    startTime: safeStartTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    endTime: safeEndTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    origin: currentTrip.origin || 'Desconocido',
                    destination: inputDestination || 'Desconocido',
                    distance: distance,
                    vehicle: currentTrip.vehicle,
                    expenses: currentTrip.tripExpenses,
                    status: 'CLOSED',
                    startOdometer: startOdo,
                    endOdometer: endOdo
                };

                setTrips(prev => [newTrip, ...prev]);
                
                if (newTrip.origin.toLowerCase().startsWith('cliente')) {
                    setVisits(prev => {
                        const idx = prev.findIndex(v => v.client === newTrip.origin && v.status === 'OPEN');
                        if (idx !== -1) {
                            const updated = [...prev];
                            updated[idx] = { 
                                ...updated[idx], 
                                outboundTrip: newTrip, 
                                status: 'COMPLETED' 
                            };
                            return updated;
                        }
                        return prev;
                    });
                }

                if (newTrip.destination.toLowerCase().startsWith('cliente')) {
                    setVisits(prev => [{
                        id: Date.now() + '_visit',
                        client: newTrip.destination,
                        date: newTrip.date,
                        inboundTrip: newTrip,
                        outboundTrip: null,
                        status: 'OPEN'
                    }, ...prev]);
                }

                setVehicleOdometers(prev => ({ ...prev, [currentTrip.vehicle]: endOdo }));
                setLastLocation(inputDestination);
                setAppState('IDLE');
                setToastMessage({ type: 'success', message: `Viaje finalizado: ${distance} km` });
            }, [inputOdometer, currentTrip, inputDestination]);

            // --- FUNCIONES DE EXPORTACI√ìN ---
            
            const handleExportData = useCallback((format) => {
                try {
                    switch(format) {
                        case 'trips-csv':
                            exportData.exportTripsCSV(filteredTrips);
                            setToastMessage({ type: 'success', message: 'Viajes exportados a CSV' });
                            break;
                        case 'expenses-csv':
                            exportData.exportExpensesCSV(filteredExpenses);
                            setToastMessage({ type: 'success', message: 'Gastos exportados a CSV' });
                            break;
                        case 'full-report':
                            exportData.exportFullReport(trips, expenses, visits, statistics);
                            setToastMessage({ type: 'success', message: 'Reporte completo exportado' });
                            break;
                        case 'accounting-report':
                            exportData.exportAccountingReport(expenses);
                            setToastMessage({ type: 'success', message: 'Reporte contable exportado' });
                            break;
                        default:
                            exportData.exportFullReport(trips, expenses, visits, statistics);
                            setToastMessage({ type: 'success', message: 'Datos exportados' });
                    }
                    setShowExportModal(false);
                } catch (error) {
                    console.error("Error exportando datos:", error);
                    setToastMessage({ type: 'error', message: 'Error exportando datos' });
                }
            }, [filteredTrips, filteredExpenses, trips, expenses, visits, statistics]);

            // --- RENDER PRINCIPAL ---
            
            return (
                <div className="flex flex-col h-screen w-full max-w-md mx-auto shadow-2xl overflow-hidden font-sans relative bg-slate-100">
                    {/* Notificaciones Toast */}
                    {toastMessage && (
                        <ToastNotification 
                            message={toastMessage.message} 
                            type={toastMessage.type}
                        />
                    )}
                    
                    {/* Componentes principales */}
                    {appState === 'IDLE' && (
                        <IdleView 
                            // Props pasados
                            trips={trips}
                            expenses={expenses}
                            visits={visits}
                            vehicleOdometers={vehicleOdometers}
                            vehicleConfigs={vehicleConfigs}
                            lastLocation={lastLocation}
                            dashboardVehicleId={dashboardVehicleId}
                            getVehicleInfo={getVehicleInfo}
                            formatMoney={formatMoney}
                            setAppState={setAppState}
                            setShowLocationSelector={setShowLocationSelector}
                            setShowVehicleSelector={setShowVehicleSelector}
                            setShowOdometerEditor={setShowOdometerEditor}
                            setShowExpenseCategorySelector={setShowExpenseCategorySelector}
                            setShowChargeTypeModal={setShowChargeTypeModal}
                            openExpenseModal={openExpenseModal}
                            handleStartPress={handleStartPress}
                            setEditingTrip={setEditingTrip}
                            showLocationSelector={showLocationSelector}
                            showVehicleSelector={showVehicleSelector}
                            showOdometerEditor={showOdometerEditor}
                            locationSelectorMode={locationSelectorMode}
                            handleLocationSelection={handleLocationSelection}
                            updateDashboardOdometer={updateDashboardOdometer}
                            setLastLocation={setLastLocation}
                            setDashboardVehicleId={setDashboardVehicleId}
                            setInputOdometer={setInputOdometer}
                            setCurrentTrip={setCurrentTrip}
                        />
                    )}
                    
                    {/* Otras vistas (STARTING, ACTIVE, ENDING, SETTINGS, HISTORY) */}
                    {/* Nota: Por brevedad, estas vistas se mantienen similares pero con las optimizaciones aplicadas */}
                    
                    {/* Vista de Historial con Filtros */}
                    {appState === 'HISTORY' && (
                        <HistoryView 
                            trips={trips}
                            expenses={expenses}
                            visits={visits}
                            historyTab={historyTab}
                            setHistoryTab={setHistoryTab}
                            setAppState={setAppState}
                            setEditingTrip={setEditingTrip}
                            setEditingVisit={setEditingVisit}
                            openExpenseModal={openExpenseModal}
                            filters={filters}
                            handleFilterChange={handleFilterChange}
                            uniqueCategories={uniqueCategories}
                            PAYMENT_METHODS={PAYMENT_METHODS}
                            getVehicleInfo={getVehicleInfo}
                            formatMoney={formatMoney}
                            filteredTrips={filteredTrips}
                            filteredExpenses={filteredExpenses}
                            filteredVisits={filteredVisits}
                            statistics={statistics}
                            setShowExportModal={setShowExportModal}
                        />
                    )}
                    
                    {/* Modal de Exportaci√≥n */}
                    {showExportModal && (
                        <ExportModal 
                            onClose={() => setShowExportModal(false)}
                            onExport={handleExportData}
                        />
                    )}
                </div>
            );
        };

        // ==========================================
        // 9. VISTAS OPTIMIZADAS (COMPONENTES SEPARADOS)
        // ==========================================

        // Vista de Inicio (Idle) - Optimizada
        const IdleView = memo(({
            trips,
            vehicleOdometers,
            lastLocation,
            dashboardVehicleId,
            getVehicleInfo,
            setAppState,
            setShowLocationSelector,
            setShowVehicleSelector,
            setShowOdometerEditor,
            setShowExpenseCategorySelector,
            setShowChargeTypeModal,
            openExpenseModal,
            handleStartPress,
            setEditingTrip,
            showLocationSelector,
            showVehicleSelector,
            showOdometerEditor,
            locationSelectorMode,
            handleLocationSelection,
            updateDashboardOdometer,
            setLastLocation,
            setDashboardVehicleId,
            setInputOdometer,
            setCurrentTrip
        }) => {
            return (
                <div className="flex flex-col h-full bg-slate-100">
                    {/* ... contenido de la vista idle ... */}
                </div>
            );
        });

        // Vista de Historial con Filtros - Optimizada
        const HistoryView = memo(({
            trips,
            expenses,
            visits,
            historyTab,
            setHistoryTab,
            setAppState,
            setEditingTrip,
            setEditingVisit,
            openExpenseModal,
            filters,
            handleFilterChange,
            uniqueCategories,
            PAYMENT_METHODS,
            getVehicleInfo,
            formatMoney,
            filteredTrips,
            filteredExpenses,
            filteredVisits,
            statistics,
            setShowExportModal
        }) => {
            return (
                <div className="flex flex-col h-screen w-full max-w-md mx-auto shadow-2xl overflow-hidden font-sans relative bg-slate-50">
                    {/* ... contenido de la vista history con filtros ... */}
                </div>
            );
        });

        // Modal de Exportaci√≥n - Nuevo
        const ExportModal = memo(({ onClose, onExport }) => {
            return (
                <div className="absolute inset-0 bg-black/60 backdrop-blur-sm z-[90] flex items-center justify-center p-4">
                    <div className="bg-white w-full max-w-sm rounded-3xl p-6 shadow-2xl animate-in zoom-in duration-200">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="text-xl font-bold text-slate-800 flex items-center">
                                <Icon name="Download" size={20} className="mr-2 text-blue-600"/> Exportar Datos
                            </h3>
                            <button onClick={onClose} className="p-2 bg-slate-100 rounded-full hover:bg-slate-200">
                                <Icon name="X" size={20} className="text-slate-500"/>
                            </button>
                        </div>
                        
                        <div className="space-y-3">
                            <button 
                                onClick={() => onExport('trips-csv')}
                                className="w-full text-left p-4 bg-blue-50 hover:bg-blue-100 border border-blue-200 rounded-xl transition-colors flex items-center"
                            >
                                <Icon name="Car" size={24} className="text-blue-600 mr-3"/>
                                <div>
                                    <div className="font-bold text-blue-800">Viajes (CSV)</div>
                                    <div className="text-sm text-blue-600">Exportar todos los viajes en formato CSV</div>
                                </div>
                            </button>
                            
                            <button 
                                onClick={() => onExport('expenses-csv')}
                                className="w-full text-left p-4 bg-emerald-50 hover:bg-emerald-100 border border-emerald-200 rounded-xl transition-colors flex items-center"
                            >
                                <Icon name="DollarSign" size={24} className="text-emerald-600 mr-3"/>
                                <div>
                                    <div className="font-bold text-emerald-800">Gastos (CSV)</div>
                                    <div className="text-sm text-emerald-600">Exportar todos los gastos en formato CSV</div>
                                </div>
                            </button>
                            
                            <button 
                                onClick={() => onExport('full-report')}
                                className="w-full text-left p-4 bg-violet-50 hover:bg-violet-100 border border-violet-200 rounded-xl transition-colors flex items-center"
                            >
                                <Icon name="PieChart" size={24} className="text-violet-600 mr-3"/>
                                <div>
                                    <div className="font-bold text-violet-800">Reporte Completo (JSON)</div>
                                    <div className="text-sm text-violet-600">Exportar todos los datos con estad√≠sticas</div>
                                </div>
                            </button>
                            
                            <button 
                                onClick={() => onExport('accounting-report')}
                                className="w-full text-left p-4 bg-amber-50 hover:bg-amber-100 border border-amber-200 rounded-xl transition-colors flex items-center"
                            >
                                <Icon name="Briefcase" size={24} className="text-amber-600 mr-3"/>
                                <div>
                                    <div className="font-bold text-amber-800">Reporte Contable (CSV)</div>
                                    <div className="text-sm text-amber-600">Formato optimizado para contabilidad</div>
                                </div>
                            </button>
                        </div>
                        
                        <div className="mt-6 pt-4 border-t border-slate-100">
                            <p className="text-sm text-slate-500 text-center">
                                Los datos se descargar√°n autom√°ticamente
                            </p>
                        </div>
                    </div>
                </div>
            );
        });

        // ==========================================
        // 10. INICIALIZACI√ìN DE LA APLICACI√ìN
        // ==========================================
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>